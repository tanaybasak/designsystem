/******************************************************************
 * HCL Confidential
 *
 * Copyright HCL Technologies Ltd. 2019 All rights reserved.
 *
 *******************************************************************
 */

/*
 * This file contains all globally applicable @mixins
 */

// GRID SYSTEMS
@mixin generate-container($gutter: $total-gutter-width) {
  width: 100%;
  padding-right: $gutter / 2;
  padding-left: $gutter / 2;
  margin-right: auto;
  margin-left: auto;
}

@mixin generate-row($gutter: $total-gutter-width) {
  display: flex;
  flex-wrap: wrap;
  margin-right: -$gutter / 2;
  margin-left: -$gutter / 2;
}

@mixin generate-col($size, $cols: $grid-columns) {
  flex: 0 0 percentage($size / $cols);
  max-width: percentage($size / $cols); // Applies to IE10+ and Firefox.
}

@mixin generate-col-offset($size, $cols: $grid-columns) {
  $num: $size / $cols;
  margin-left: if($num==0, 0, percentage($num));
}

// Framework grid generation
//
// Generate the correct number of grid classes given any value of `$grid-columns`.
@mixin generate-cols(
  $cols: $grid-columns,
  $gutter: $total-gutter-width,
  $breakpoints: $grid-breakpoints
) {
  @each $breakpoint in map-keys($breakpoints) {
    $infix: breakpoint-infix($breakpoint, $breakpoints);

    // Allow columns to stretch full width below their breakpoints
    @for $i from 1 through $cols {
      .#{$prefix}-col#{$infix}-#{$i} {
        @extend %common-col-rules;
      }
    }

    .#{$prefix}-col#{$infix},
    .#{$prefix}-col#{$infix}-auto {
      @extend %common-col-rules;
    }

    @include media-breakpoint-up($breakpoint, $breakpoints) {
      // Provide basic `.#{$prefix}-col-{bp}` classes for equal-width flexbox columns
      .#{$prefix}-col#{$infix} {
        flex-basis: 0;
        flex-grow: 1;
        max-width: 100%;
      }

      .#{$prefix}-col#{$infix}-auto {
        flex: 0 0 auto;
        width: auto;
        max-width: 100%; // Reset earlier grid tiers
      }

      @for $i from 1 through $cols {
        .#{$prefix}-col#{$infix}-#{$i} {
          @include generate-col($i, $cols);
        }
      }

      .#{$prefix}-order#{$infix}-first {
        order: -1;
      }

      .#{$prefix}-order#{$infix}-last {
        order: $cols + 1;
      }

      @for $i from 0 through $cols {
        .#{$prefix}-order#{$infix}-#{$i} {
          order: $i;
        }
      }

      // `$cols - 1` because offsetting by the width of an entire row isn't possible
      @for $i from 0 through ($cols - 1) {
        // Avoid emitting useless .#{$prefix}-offset-0
        @if not($infix== "" and $i==0) {
          .#{$prefix}-offset#{$infix}-#{$i} {
            @include generate-col-offset($i, $cols);
          }
        }
      }
    }
  }
}

// Resize
@mixin resizable($direction) {
  overflow: auto;
  resize: $direction;
}

// Clearfix
@mixin clearfix() {
  &::after {
    display: block;
    clear: both;
    content: "";
  }
}

// MEDIA QUERIES
@mixin respond-to($breakpoint) {
  @if $breakpoint==phone {
    @media (min-width: #{$mobile-width}) and (max-width: #{$tablet-width - 1px}) {
      @content;
    }
  } @else if $breakpoint==tablet {
    @media (min-width: #{$tablet-width}) and (max-width: #{$desktop-width - 1px}) {
      @content;
    }
  } @else if $breakpoint==desktop {
    @media (min-width: #{$desktop-width}) {
      @content;
    }
  }
}

// Line height
@function getLineHeight($font-size) {
  @return $font-size * 1.5;
}

// px to rem
@mixin pxtorem($value) {
  font-size: ($value/$base-font-size-px) + rem;
}

// close icon
@mixin hcl-close-icon(
  $size: 16,
  $bg-color: transparent,
  $fg-color: $black,
  $rounded: false
) {
  width: #{$size}px;
  height: #{$size}px;
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background-color: $bg-color;
  cursor: pointer;

  &::before,
  &::after {
    content: " ";
    position: absolute;
    width: 2px;
    background-color: lighten($fg-color, 20%);
  }

  @if $rounded {
    border-radius: 50%;

    &::before,
    &::after {
      height: #{round($size - 10)}px;
    }
  } @else {
    &::before,
    &::after {
      height: #{$size}px;
    }
  }

  &::before {
    transform: rotate(45deg);
  }

  &::after {
    transform: rotate(-45deg);
  }

  &:hover {
    &::before,
    &::after {
      background-color: lighten($fg-color, 0);
    }
  }
}

// ellipsis icon
@mixin hcl-ellipsis($font-size: 0.8rem) {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: $font-size;

  @include themify($themes) {
    color: themed("interactive_icon");
    background-color: themed("interactive_bg");
  }

  &::after {
    content: "\2022 \2022 \2022";
    transform: rotate(90deg);
    padding: 0 0.5rem;
  }

  &.horizontal-ellipsis {
    &::after {
      transform: none;
    }
  }
}

// HOVER
@mixin hover {
  &:hover {
    @content;
  }
}

@mixin hover-focus {
  &:hover,
  &:focus {
    @content;
  }
}

@mixin nav-active {
  background-image: linear-gradient(
    to top,
    $white 0%,
    $white 4%,
    transparent 4%
  );
  background-size: cover;
  transition: all ease 0.1s;
}

@mixin clearfix() {
  &::after {
    display: block;
    content: "";
    clear: both;
  }
}

// Input Fields Color Maps
$inputColor-map: (
  "color-1": #152935,
  "color-2": #5a6872,
  "color-3": #efefef,
  "color-5": #3d70b2,
);

// getInputColor(<requiredColor>, <propertyNametoApply>)
@mixin getInputColor($color, $property) {
  @if map-has-key($inputColor-map, $color) {
    #{$property}: map-get($inputColor-map, $color);
  } @else {
    @warn 'This is not define in the HCL design System - `#{$color} #{$property}`';
  }
}

// getFormControl(<control>)
@mixin getFormControl($which) {
  @if ($which== "inputcontrol") {
    font-size: 0.875rem;
    width: 100%;
    height: $input-height;
    padding: $input-padding-y $input-padding-x;

    @include themify($themes) {
      color: themed("input_text");
      background-color: themed("input_bg");
      border-bottom: 1px solid themed("input_border");
    }

    border: none;
    &:focus {
      outline: none;

      @include themify($themes) {
        border-bottom: 2px solid themed("interactive_border");
      }

      & ~ label.#{$prefix}-label {
        @include themify($themes) {
          color: themed("default_text");
        }
      }
    }

    &[disabled] {
      cursor: not-allowed;

      @include themify($themes) {
        background-color: rgba($blue-secondary, themed("disabled_all"));
      }

      & ~ label,
      & ~ .#{$prefix}-error-msg,
      & ~ .#{$prefix}-helper-text {
        @include themify($themes) {
          opacity: themed("disabled_all");
        }
      }
    }
  } @else {
    @warn 'This is not define in the HCL design System!';
  }
}

// getErrorMarkup(<control>)
@mixin getErrorMarkup($which) {
  @if ($which== "inputcontrol") {
    .#{$prefix}-error-msg {
      @include getFontWeight("regular");
      font-size: 0.75rem;
      line-height: getLineHeight(0.75rem);

      @include themify($themes) {
        color: themed("danger_text");
      }

      margin-top: 0.25rem;
    }
  } @else {
    @warn 'This is not define in the HCL design System! - `#{$which}`';
  }
}

@mixin groupOption($which) {
  > .#{$prefix}-#{$which}-item:not(:first-of-type) {
    margin-left: 1rem;
  }

  &.#{$prefix}-stack-vertical {
    > .#{$prefix}-#{$which}-item:not(:first-of-type) {
      margin-left: 0;
    }
  }
}

// theme
@mixin themify($themes: $themes) {
  @each $theme, $map in $themes {
    .theme-#{$theme} & {
      $theme-map: () !global;

      @each $key, $submap in $map {
        $value: map-get(map-get($themes, $theme), "#{$key}");
        $theme-map: map-merge(
          $theme-map,
          (
            $key: $value,
          )
        ) !global;
      }

      @content;
      $theme-map: null !global;
    }
  }
}
